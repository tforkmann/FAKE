using System;
using System.Collections.Generic;
using System.IO;
using Fake;
using Machine.Specifications;
using Microsoft.FSharp.Core;

namespace Test.FAKECore
{
    public class when_accessing_internals
    {
        It should_have_access_to_FAKE_internals =
            () => AssemblyInfoFile.getDependencies(new List<AssemblyInfoFile.Attribute>());
    }

    public class when_using_version_attributes
    {
        private static string Input = "1.0.0+0e5da7a";

        It normalizes_the_string_for_Version = () =>
        {
            var attribute = AssemblyInfoFile.Attribute.Version(Input);
            attribute.Value.ShouldEqual("\"1.0.0\"");
        };

        It normalizes_the_string_for_FileVersion = () =>
        {
            var attribute = AssemblyInfoFile.Attribute.FileVersion(Input);
            attribute.Value.ShouldEqual("\"1.0.0\"");
        };

        It leaves_string_as_is_for_InformationalVersion = () =>
        {
            var attribute = AssemblyInfoFile.Attribute.InformationalVersion(Input);
            attribute.Value.ShouldEqual("\"1.0.0+0e5da7a\"");
        };
    }

    public class when_using_fsharp_task_with_default_config
    {
        It should_use_system_namespace_and_emit_a_version_module = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateFSharpAssemblyInfo(infoFile, attributes);
            const string expected = "// Auto-Generated by FAKE; do not edit\r\nnamespace System\r\nopen System.Reflection\r\n\r\n[<assembly: AssemblyProductAttribute(\"TestLib\")>]\r\n[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\ndo ()\r\n\r\nmodule internal AssemblyVersionInformation =\r\n    let [<Literal>] AssemblyProduct = \"TestLib\"\r\n    let [<Literal>] AssemblyVersion = \"1.0.0.0\"\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It should_emit_valid_syntax_when_there_is_more_then_one_attribute_of_the_same_type = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0"),
                AssemblyInfoFile.Attribute.InternalsVisibleTo("a"),
                AssemblyInfoFile.Attribute.InternalsVisibleTo("a.b"),
            };
            AssemblyInfoFile.CreateFSharpAssemblyInfo(infoFile, attributes);

            const string expected = "// Auto-Generated by FAKE; do not edit\r\nnamespace System\r\nopen System.Reflection\r\nopen System.Runtime.CompilerServices\r\n\r\n[<assembly: AssemblyProductAttribute(\"TestLib\")>]\r\n[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\n[<assembly: InternalsVisibleToAttribute(\"a\")>]\r\n[<assembly: InternalsVisibleToAttribute(\"a.b\")>]\r\ndo ()\r\n\r\nmodule internal AssemblyVersionInformation =\r\n    let [<Literal>] AssemblyProduct = \"TestLib\"\r\n    let [<Literal>] AssemblyVersion = \"1.0.0.0\"\r\n    let [<Literal>] InternalsVisibleTo = \"a\"\r\n    let [<Literal>] InternalsVisibleTo_1 = \"a.b\"\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It update_attributes_should_update_attributes_in_fs_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".fs");
            const string original = "namespace System\r\nopen System.Reflection\r\n\r\n" +
                                     "[<assembly: AssemblyProduct(\"TestLib\")>]\r\n" +
                                     "[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\n";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLibNew"),
                AssemblyInfoFile.Attribute.Version("2.0.0.0")
            };
            AssemblyInfoFile.UpdateAttributes(infoFile, attributes);

            // Assert
            const string expected = "namespace System\r\nopen System.Reflection\r\n\r\n" +
                                    "[<assembly: AssemblyProduct(\"TestLibNew\")>]\r\n" +
                                    "[<assembly: AssemblyVersionAttribute(\"2.0.0.0\")>]\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It get_attribute_should_read_attribute_from_fs_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".fs");
            const string original = "namespace System\r\nopen System.Reflection\r\n\r\n" +
                                     "[<assembly: AssemblyProduct(\"TestLib\")>]\r\n" +
                                     "[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\n";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var productAttr = AssemblyInfoFile.GetAttribute("AssemblyProduct", infoFile).Value;
            var versionAttr = AssemblyInfoFile.GetAttribute("AssemblyVersion", infoFile).Value;

            // Assert
            productAttr.Value.ShouldEqual("TestLib");
            versionAttr.Value.ShouldEqual("1.0.0.0");
        };
    }

    public class when_using_fsharp_task_with_custom_config
    {
        It should_use_custom_namespace_and_not_emit_a_version_module = () =>
        {
            var customConfig = new AssemblyInfoFile.AssemblyInfoFileConfig(false, new FSharpOption<bool>(false), new FSharpOption<string>("Custom"));
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateFSharpAssemblyInfoWithConfig(infoFile, attributes, customConfig);
            const string expected = "// Auto-Generated by FAKE; do not edit\r\nnamespace Custom\r\nopen System.Reflection\r\n\r\n[<assembly: AssemblyProductAttribute(\"TestLib\")>]\r\n[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\ndo ()\r\n\r\n";
            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };
    }

    public class when_using_csharp_task_with_default_config
    {
        It should_use_system_namespace_and_emit_a_version_module = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateCSharpAssemblyInfo(infoFile, attributes);
            const string expected = "// <auto-generated/>\r\nusing System.Reflection;\r\n\r\n[assembly: AssemblyProductAttribute(\"TestLib\")]\r\n[assembly: AssemblyVersionAttribute(\"1.0.0.0\")]\r\nnamespace System {\r\n    internal static class AssemblyVersionInformation {\r\n        internal const System.String AssemblyProduct = \"TestLib\";\r\n        internal const System.String AssemblyVersion = \"1.0.0.0\";\r\n    }\r\n}\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It should_emit_valid_syntax_when_there_is_more_then_one_attribute_of_the_same_type = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0"),
                AssemblyInfoFile.Attribute.InternalsVisibleTo("a"),
                AssemblyInfoFile.Attribute.InternalsVisibleTo("b")
            };
            AssemblyInfoFile.CreateCSharpAssemblyInfo(infoFile, attributes);

            const string expected = "// <auto-generated/>\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\n\r\n[assembly: AssemblyProductAttribute(\"TestLib\")]\r\n[assembly: AssemblyVersionAttribute(\"1.0.0.0\")]\r\n[assembly: InternalsVisibleToAttribute(\"a\")]\r\n[assembly: InternalsVisibleToAttribute(\"b\")]\r\nnamespace System {\r\n    internal static class AssemblyVersionInformation {\r\n        internal const System.String AssemblyProduct = \"TestLib\";\r\n        internal const System.String AssemblyVersion = \"1.0.0.0\";\r\n        internal const System.String InternalsVisibleTo = \"a\";\r\n        internal const System.String InternalsVisibleTo_1 = \"b\";\r\n    }\r\n}\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It update_attributes_should_update_attributes_in_cs_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".cs");
            const string original = "// <auto-generated/>\r\nusing System.Reflection;\r\n\r\n" +
                                    "[assembly: AssemblyProduct(\"TestLib\")]\r\n" +
                                    "[assembly: AssemblyVersionAttribute(\"1.0.0.0\")]\r\n";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLibNew"),
                AssemblyInfoFile.Attribute.Version("2.0.0.0")
            };
            AssemblyInfoFile.UpdateAttributes(infoFile, attributes);

            // Assert
            const string expected = "// <auto-generated/>\r\nusing System.Reflection;\r\n\r\n" +
                                    "[assembly: AssemblyProduct(\"TestLibNew\")]\r\n" +
                                    "[assembly: AssemblyVersionAttribute(\"2.0.0.0\")]\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It get_attribute_should_read_attribute_from_cs_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".cs");
            const string original = "// <auto-generated/>\r\nusing System.Reflection;\r\n\r\n" +
                                    "[assembly: AssemblyProduct(\"TestLib\")]\r\n" +
                                    "[assembly: AssemblyVersionAttribute(\"1.0.0.0\")]\r\n";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var productAttr = AssemblyInfoFile.GetAttribute("AssemblyProduct", infoFile).Value;
            var versionAttr = AssemblyInfoFile.GetAttribute("AssemblyVersion", infoFile).Value;

            // Assert
            productAttr.Value.ShouldEqual("TestLib");
            versionAttr.Value.ShouldEqual("1.0.0.0");
        };
    }

    public class when_using_csharp_task_with_custom_config
    {
        It should_emit_resharper_suppressions_if_enabled = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };

            var customConfig = new AssemblyInfoFile.AssemblyInfoFileConfig(true, new FSharpOption<bool>(true), new FSharpOption<string>("System"));

            AssemblyInfoFile.CreateCSharpAssemblyInfoWithConfig(infoFile, attributes, customConfig);
            const string expected = "// <auto-generated/>\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Reflection;\r\n\r\n[assembly: AssemblyProductAttribute(\"TestLib\")]\r\n[assembly: AssemblyVersionAttribute(\"1.0.0.0\")]\r\nnamespace System {\r\n    [SuppressMessage(\"ReSharper\", \"RedundantNameQualifier\")]\r\n    [SuppressMessage(\"ReSharper\", \"UnusedMember.Global\")]\r\n    [SuppressMessage(\"ReSharper\", \"BuiltInTypeReferenceStyle\")]\r\n    internal static class AssemblyVersionInformation {\r\n        internal const System.String AssemblyProduct = \"TestLib\";\r\n        internal const System.String AssemblyVersion = \"1.0.0.0\";\r\n    }\r\n}\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };
    }

    public class when_using_cppcli_task_with_default_config
    {
        It should_emit_valid_syntax = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateCppCliAssemblyInfo(infoFile, attributes);
            const string expected = "// <auto-generated/>\r\nusing namespace System::Reflection;\r\n\r\n[assembly:AssemblyProductAttribute(\"TestLib\")];\r\n[assembly:AssemblyVersionAttribute(\"1.0.0.0\")];\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It update_attributes_should_update_attributes_in_cpp_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".cpp");
            const string original = "// <auto-generated/>\r\nusing namespace System::Reflection;\r\n\r\n" +
                                    "[assembly:AssemblyProduct(\"TestLib\")];\r\n" +
                                    "[assembly:AssemblyVersionAttribute(\"1.0.0.0\")];\r\n";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLibNew"),
                AssemblyInfoFile.Attribute.Version("2.0.0.0")
            };
            AssemblyInfoFile.UpdateAttributes(infoFile, attributes);

            // Assert
            const string expected = "// <auto-generated/>\r\nusing namespace System::Reflection;\r\n\r\n" +
                                    "[assembly:AssemblyProduct(\"TestLibNew\")];\r\n" +
                                    "[assembly:AssemblyVersionAttribute(\"2.0.0.0\")];\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It get_attribute_should_read_attribute_from_cpp_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".cpp");
            const string original = "// <auto-generated/>\r\nusing namespace System::Reflection;\r\n\r\n" +
                                    "[assembly:AssemblyProduct(\"TestLib\")];\r\n" +
                                    "[assembly:AssemblyVersionAttribute(\"1.0.0.0\")];\r\n";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var productAttr = AssemblyInfoFile.GetAttribute("AssemblyProduct", infoFile).Value;
            var versionAttr = AssemblyInfoFile.GetAttribute("AssemblyVersion", infoFile).Value;

            // Assert
            productAttr.Value.ShouldEqual("TestLib");
            versionAttr.Value.ShouldEqual("1.0.0.0");
        };
    }


    public class when_using_vb_task_with_default_config
    {
        It should_emit_valid_syntax = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateVisualBasicAssemblyInfo(infoFile, attributes);
            const string expected = "' <auto-generated/>\r\nImports System.Reflection\r\n\r\n<assembly: AssemblyProductAttribute(\"TestLib\")>\r\n<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>\r\nFriend NotInheritable Class AssemblyVersionInformation\r\n    Friend Const AssemblyProduct As System.String = \"TestLib\"\r\n    Friend Const AssemblyVersion As System.String = \"1.0.0.0\"\r\nEnd Class\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It should_emit_valid_syntax_when_there_is_more_then_one_attribute_of_the_same_type = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0"),
                AssemblyInfoFile.Attribute.InternalsVisibleTo("a"),
                AssemblyInfoFile.Attribute.InternalsVisibleTo("b")
            };
            AssemblyInfoFile.CreateVisualBasicAssemblyInfo(infoFile, attributes);

            const string expected = "' <auto-generated/>\r\nImports System.Reflection\r\nImports System.Runtime.CompilerServices\r\n\r\n<assembly: AssemblyProductAttribute(\"TestLib\")>\r\n<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>\r\n<assembly: InternalsVisibleToAttribute(\"a\")>\r\n<assembly: InternalsVisibleToAttribute(\"b\")>\r\nFriend NotInheritable Class AssemblyVersionInformation\r\n    Friend Const AssemblyProduct As System.String = \"TestLib\"\r\n    Friend Const AssemblyVersion As System.String = \"1.0.0.0\"\r\n    Friend Const InternalsVisibleTo As System.String = \"a\"\r\n    Friend Const InternalsVisibleTo_1 As System.String = \"b\"\r\nEnd Class\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It update_attributes_should_update_attributes_in_vb_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".vb");
            const string original = "' <auto-generated/>\r\nImports System.Reflection\r\n\r\n" +
                                    "<assembly: AssemblyProduct(\"TestLib\")>\r\n" +
                                    "<Assembly: AssemblyCompany(\"TestCompany\")>\r\n" +
                                    "<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>\r\n" +
                                    "<Assembly: ComVisibleAttribute(false)>";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLibNew"),
                AssemblyInfoFile.Attribute.Company("TestCompanyNew"),
                AssemblyInfoFile.Attribute.Version("2.0.0.0")
            };
            AssemblyInfoFile.UpdateAttributes(infoFile, attributes);

            // Assert
            const string expected = "' <auto-generated/>\r\nImports System.Reflection\r\n\r\n" +
                                    "<assembly: AssemblyProduct(\"TestLibNew\")>\r\n" +
                                    "<Assembly: AssemblyCompany(\"TestCompanyNew\")>\r\n" +
                                    "<assembly: AssemblyVersionAttribute(\"2.0.0.0\")>\r\n" +
                                    "<Assembly: ComVisibleAttribute(false)>";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };

        It get_attribute_should_read_attribute_from_vb_file = () =>
        {
            // Arrange. Create attribute both with and without "Attribute" at the end, and also
            // case-insensitive attributes
            string infoFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid() + ".vb");
            const string original = "' <auto-generated/>\r\nImports System.Reflection\r\n\r\n" +
                                    "<assembly: AssemblyProduct(\"TestLib\")>\r\n" +
                                    "<Assembly: AssemblyCompany(\"TestCompany\")>\r\n" +
                                    "<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>\r\n" +
                                    "<Assembly: ComVisibleAttribute(false)>";
            File.WriteAllText(infoFile, original.Replace("\r\n", Environment.NewLine));

            // Act
            var productAttr = AssemblyInfoFile.GetAttribute("AssemblyProduct", infoFile).Value;
            var companyAttr = AssemblyInfoFile.GetAttribute("AssemblyCompany", infoFile).Value;
            var versionAttr = AssemblyInfoFile.GetAttribute("AssemblyVersion", infoFile).Value;
            var comVisibleAttr = AssemblyInfoFile.GetAttribute("ComVisible", infoFile).Value;

            // Assert
            productAttr.Value.ShouldEqual("TestLib");
            companyAttr.Value.ShouldEqual("TestCompany");
            versionAttr.Value.ShouldEqual("1.0.0.0");
            comVisibleAttr.Value.ShouldEqual("false");
        };
    }
}
